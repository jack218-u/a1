// golang仍然有面向对象编程的继承,封装和多态的特性,只是实现方式和其他opp语言不一样
//封装(encapsulation)就是把抽象出的字段和对字段的操作封装在一起，数据被保护在内部，程序的其他包只有通过被授权的操作(方法),才能对字段进行操作
//封装的理解和好处
//1. 隐藏实现细节
//2. 提可以对数据进行验证,保证安全合理(Age)
//如何体现封装
//1. 对结构中的属性进行封装
//2. 通过方法,包实现封装
//封装的实现步骤
//1.将结构体、字段(属性)的首字母小写(不能导出了，其他包不能使用，类似private)
//2.给结构体所在包提供一个工厂模式的函数,首字母大写，类似一个构造函数
//3.提供一个首字母大写的Set方法(类似其他语言的public),用于对属性判断并赋值 //别的包调用方法
/*
func (var 结构体类型名) SetXX(参数列表) (返回值列表){
加入数据验证的业务逻辑
var.字段=参数
}
*/
//4.提供一个首字母大写的Get方法(类似其他语言的public),用于获取属性的值 //别的包调用方法
/*
func (var结构体类型名)GetXXX(){
	return var.字段
}
*/
//特别说明：在golang开发中没有特别强调封装,和java有所不同,不要用java的语法特性来看待golang,golang本身对面向对象的特性做了简化的.
package main

import (
	"abc/203-/204/model"
	"fmt"
)

func main() {

	p := model.NewPerson("smith")
	p.SetAge(18)
	p.SetSal(5000)
	fmt.Println(*p) //输出p的取值,加* 表示取指针指向的值
	fmt.Println(p.Name, " age =", p.GetAge(), " sal = ", p.GetSal())

}
